-- Verification
select e.name verificator,
	va.start_processing_at::date date,
	date_trunc('second', processed_at_previous)::time pause_started_at,
	(date_part('hour', va.start_processing_at - processed_at_previous) * 60 + date_part('minute', va.start_processing_at - processed_at_previous) + (date_part('second', va.start_processing_at - processed_at_previous)/60)) pause_duration_min
from (
	select *,
		lead(processed_at, 1) over (partition by employee_id order by start_processing_at desc) processed_at_previous
	from stage_kz.verifying_applications va
) va
left join stage_kz.employees e on va.employee_id = e.id
where va.start_processing_at::date >= '2021-01-01' and e.name is not null and va.start_processing_at is not null and processed_at_previous::date = va.start_processing_at::date
order by 1, 2 desc, 3


select e.name verificator, va.start_processing_at::date date,
	min(va.start_processing_at) first_appl_start_time,
	max(va.start_processing_at) last_appl_start_time,
	max(va.processed_at) last_appl_end_time,
	avg(date_part('hour', va.processed_at - va.start_processing_at) * 60 + date_part('minute', va.processed_at - va.start_processing_at) + (date_part('second', va.processed_at - va.start_processing_at)/60)) avg_processing_time,
	sum(case when va.status = 'did not answer the phone' and va.processed_at <= va.start_processing_at + interval '10' second then 1 else 0 end) cnt_less10sec,
	sum(case when va.start_processing_at < va2.processed_at and va.start_processing_at::date = va2.processed_at::date then 1 else 0 end) cnt_parallel
from stage_kz.verifying_applications va
left join stage_kz.employees e on va.employee_id = e.id
left join lateral (
	select *
	from stage_kz.verifying_applications va2
	where va2.employee_id = va.employee_id and va2.start_processing_at < va.start_processing_at
	order by va2.start_processing_at desc
	limit 1
) va2 on true
where va.start_processing_at::date >= '2021-01-01' and e.name is not null and va.start_processing_at is not null
group by 1, 2
order by 1, 2 desc


-- Collection
with roll_rates as (
	with from_dpd_list as (
		select from_dpd
		from generate_series(-30, 31, 1) from_dpd
	),
	days_list as (
		select days_ahead
		from generate_series(1, 20, 1) days_ahead
	)
	select from_dpd,
	from_dpd - days_ahead to_dpd,
	days_ahead,
	l1.client_type_overall client_type_rr,
	l1.application_type application_type_rr,
	roll_rate
	from from_dpd_list
	cross join days_list
	left join lateral (
		select
			l1.client_type_overall,
			l1.application_type,
			sum(case when l1.max_dpd >= from_dpd then 1 else 0 end)/sum(case when l1.max_dpd >= from_dpd - days_ahead then 1 else 0 end)::float roll_rate
		from bi_kz.dim_loan_summary_master l1
		where l1.main_agreement_due_dt < '2021-12-01' and l1.main_agreement_due_dt >= '2021-10-01'
		group by 1, 2
	) l1 on true
),
l as (
	select l.main_agreement_due_dt,
		l.max_dpd current_dpd,
		l.client_type_overall,
		l.application_type,
		count(*) cnt_open_today
	from bi_kz.dim_loan_summary_master l
	where l.loan_status = 'open'
		and l.main_agreement_due_dt >= current_date - interval '30' day
		and l.main_agreement_due_dt <= current_date + interval '22' day
	group by 1, 2, 3, 4
)
select
	l.client_type_overall,
	l.application_type,
	l.main_agreement_due_dt,
	current_dpd,
	cnt_open_today,
	days_ahead,
	current_date + days_ahead predicting_date,
	from_dpd dpd_on_predicting_date,
	roll_rate,
	(cnt_open_today * roll_rate)::int cnt_open_at_date
from l
left join roll_rates on from_dpd - days_ahead = current_dpd and l.client_type_overall = client_type_rr and l.application_type = application_type_rr
order by 6, 3, 1, 2



